---
title: AI Agent入门知识
category: AI
tags:
  - agent
  - prompt
head:
  - - meta
    - name: description
      content: 全网最全的AI大模型知识点总结，让天下没有难学的八股文！
---





## AI Agent到底是什么？

从概念上来说，AI Agent（智能体）是一种不需要持续人类干预的AI系统，可以基于环境和背景信息，自主分析各种问题，做出逻辑决策，并且在没有持续人类输入的情况下处理多种任务。

AlphaGo就是一个典型的AI Agent，它可以在和人类对弈围棋的过程中，根据当前的棋局和对手的行动，自主决策下一步的动作。AI助手也是AI Agent，比如你只需要给AI助手下达一个指令，“帮我预订明早10点上海飞深圳的机票”，AI助手就能自动帮你完成从机票搜索、查询、下单、确认的全部动作。
从结构上来说，一个AI Agent包括三个部分：

**Perception（输入）：**AI Agent通过文字输入、传感器、摄像头、麦克风等等，建立起对外部世界或环境的感知。

**Brain（大脑）：**大脑是AI Agent最重要的部分，包括信息存储、记忆、知识库、规划决策系统。

**Action（行动）：**基于Brain给出的决策进行下一步行动，对于AI Agent来说，行动主要包括对外部工具的API 调用，或者对物理控制组件的信号输出。


目前在大模型热潮的背景下，媒体上所讲的AI Agent，更严格意义上来说应该叫做 LLM Agent，因为整个Agent最重要的控制中枢Brain，其底层是LLM大模型。如果未来产生了比LLM更强大更智能的AI技术基座，那同样也会产生基于新的AI基座的Agent。下文所介绍的AI Agent，如无特殊说明，都指代LLM Agent。

那么Agent和LLM大语言模型到底是什么关系呢？可以这样进行简单类比，如果把LLM（比如GPT）比作大脑中的一堆神经元，具有记忆、常识和推理等能力，那么AI Agent就是独立的人，除了拥有大脑之外，还拥有视觉、听觉、味觉等多种感官，以及拥有手和脚操作外部的工具。

因此从本质来讲，**AI Agent = 大语言模型+记忆+规划+工具使用**。


### AI Agent的构成
#### 构成一、规划Planning

Planning是整个AI Agent中最核心最关键的部分，Agent会把大型任务分解为子任务，并规划执行任务的流程。同时Agent还会对任务执行的过程进行思考和反思，从而决定是继续执行任务，还是判断任务完结并终止运行。

整个Planning模块包括两个步骤：子任务分解，反思和完善。

##### 步骤一，子任务分解

Agent 将大型任务分解为更小、更易于管理的子目标，从而高效处理复杂任务。主要的子任务分解方式包括：思维链COT（Chain of thought）、思维树TOT（Tree of thought）、思维图GOT（Graph of thought）、规划器LLM+P。

**思维链COT**

思维链COT的全称是Chain of Thought，当我们对LLM这样要求「think step by step」，会发现LLM会把问题分解成多个步骤，一步一步思考和解决，能使得输出的结果更加准确。这就是思维链，一种线性思维方式。


**COT-SC**

一个CoT出现错误的概率比较大，我们可以让Agent进行发散，尝试通过多种思路来解决问题，然后投票选择出最佳答案，这就是CoT-SC。

**思维树TOT**

思维树TOT是对思维链CoT的进一步扩展，在思维链的每一步，推理出多个分支，拓扑展开成一棵思维树。使用启发式方法评估每个推理分支对问题解决的贡献。选择搜索算法，使用广度优先搜索（BFS）或深度优先搜索（DFS）等算法来探索思维树，并进行前瞻和回溯。

**思维图GOT**

思维树ToT 的方式也存在一些缺陷，对于需要分解后再整合的问题，比如排序问题，排序我们可能需要分解和排序，然后再merge。这种情况下TOT就不行了，可以引入思维图GOT来解决。


**LLM+P**

其原理是依靠外部传统规划器来进行长视野规划，利用规划域定义语言（PDDL）作为中间接口来描述规划问题。在此过程中，LLM先将问题转化为成”Problem PDDL”形式，然后请求经典规划器根据现有的 “Domain PDDL “生成 PDDL 计划，最后将 PDDL 计划翻译回自然语言。

##### 步骤二、反思和完善

反思和完善机制在Agent 应用中发挥着重要的作用，Agent 通过完善过去的行动决策和纠正以前的错误来不断改进。尤其是在现实世界的任务中，不可能在规划环节就能做出万无一失的计划和策略，试错是不可避免的，只有通过自我反思和逐步完善，才能一步步逼近最佳结果。

反思和完善机制的实现，主要有以下几种方式。

**ReAct**

ReACT的全称是Reasoning-Action，这种模式是让大模型先进行思考，思考完再进行行动，然后根据行动的结果再进行观察，再进行思考，这样一步一步循环下去。

和ReAct相对应的是Reasoning-Only和Action-Only。在Reasoning-Only的模式下，大模型会基于任务进行逐步思考，并且不管有没有获得结果，都会把思考的每一步都执行一遍。在Action-Only的模式下，大模型就会处于完全没有规划的状态下，先进行行动再进行观察，基于观察再调整行动，导致最终结果不可控。

在实际的测试观察中，ReAct模式的效果要好于Reasoning-Only和Action-Only。


**Reflexion**

Reflecxion是一个为 Agent 配备了动态记忆和自我反思能力的框架，能够提高 Agent 的推理能力。Reflexion 具有标准的强化学习机制，其奖励模型提供了一个简单的二进制奖励机制，执行空间则遵循 ReAct 中的设置。每次行动，Agent 都会计算一个启发式 ht，并根据自我反思的结果决定环境重置以开始新的试验。

**Basic Reflection**

还有一种反思和完善的方式，其本质是利用左右互搏来实现协同进化。比如设计一个帮助用户完成市场调研报告的Agent系统，其中Generator负责输出，Reflector负责检查，通过两个角色之间不断的协同，来实现整个任务的反思和完善。

#### 构成二、记忆Memory

记忆是Agent用于获取、存储、保留和随后检索信息的过程，我们先用人脑的记忆做个类比，人脑中有多种记忆类型：

- 感官记忆：这是记忆的最早阶段，能够在原始刺激结束后保留对感官信息（视觉、听觉等）的印象，通常只能持续几秒钟。包括图标记忆、回声记忆和触觉记忆三种类型。
- 短时记忆（STM）或工作记忆：指的是我们当前意识到的信息，或者在学习和推理等复杂认知任务中所需要的信息。人类的短时记忆容量约为 7 items（Miller, 1956）、持续时长为 20-30 秒。
- 长时记忆（LTM）：长时记忆指的是能够存储很长时间，从几天到几十年不等的信息，它的存储容量基本上是无限的。长时记忆又包括显性记忆和隐性记忆，显性记忆是可以有意识地回忆起来的事实，比如事件经历和语义记忆；隐性记忆是内化后无意识的行为，比如骑自行车。

了解了人类的记忆模式，我们再来看如何将其映射到AI Agent。

感官记忆是对原始输入的嵌入表征的理解，包括文本、图像或其他模式，比如图片的纹理和风格。短时记忆即上下文学习，由于受到Transformer上下文窗口长度的限制，它是短暂的和有限的。长期记忆则可对应为外部的向量数据存储，Agent 可在查询时引用，并可通过快速检索进行访问。

还有一个非常关键的因素，大模型知识的更新。由于大模型是用海量的通用数据训练的，基础的大模型可以理解为是一个及格的通才，什么话题都知道一些，但是存在胡言乱语和幻觉现象。尤其是在面向企业端的场景，一个及格的通才是无法使用的，需要利用企业的专属数据进行喂养和训练。这个时候，就可以通过RAG【检索增强生成】技术，在基础大模型的基础上挂载企业专属的知识库，以向量数据库的方式存储，将Agent训练为一个优秀的专才。


#### 构成三、工具Tooling

为AI Agent配备工具API，比如计算器、搜索工具、代码执行器、数据库查询等工具，AI Agent就可以和物理世界交互，来解决更加实际的问题。

Agent使用工具的方式主要有以下几种：

**TALM & ToolFormer**

TALM和ToolFormer都是对 LLM 进行微调，以学习使用外部工具API。该数据集根据新增的 API 调用注释是否能够提高模型输出的质量而进行扩展。

**HuggingGPT**

HuggingGPT =ChatGPT+HuggingFace，HuggingFace是大模型领域的Github，来自全球的开发人员、企业和机构在huggingFace社区进行模型的上传、分享和部署。

从本质上来说，HuggingGPT是一个使用ChatGPT作为任务规划器的框架，ChatGPT 可根据模型的描述选择 HuggingFace 平台中可用的模型，并根据执行结果总结响应结果。

**API-Bank**

它包含 53 种常用的 API 工具、完整的工具增强的 LLM 工作流程。API 的选择相当多样化，包括搜索引擎、计算器、日历查询、智能家居控制、日程管理、健康数据管理、账户认证工作流程等。由于 API 数量众多，LLM 首先可以访问 API 搜索引擎，找到要调用的 API，然后使用相应的文档进行调用

**Function Calling**

是一种实现大型语言模型连接外部工具的机制。通过API调用LLM时，调用方可以描述函数，包括函数的功能描述、请求参数说明、响应参数说明，让LLM根据用户的输入，合适地选择调用哪个函数，同时理解用户的自然语言，并转换为调用函数的请求参数。


### AI Agent的分类


我们可以从三个角度来给AI Agent进行分类，分别是工作模式、决策方式和应用场景。在本篇文章中，先介绍前两种分类方式，后续再详细介绍AI Agent的应用场景。

#### 按工作模式分类

从工作模式来看，AI智能体可以分为单Agent、多Agent和混合Agent。

**单Agent** ：即通过单一的Agent来解决问题，不需要与其他Agent进行交互。单Agent可以根据任务执行不同的操作，如需求分析、项目读取、代码生成等。比如专门用于进行市场分析调研的Agent就是单Agent系统，只能处理市场分析这个单一任务。

**多Agent**：这种模式侧重于多个Agent之间的互动和信息共享，多个Agent协同工作，相互交流信息，共同完成更复杂的任务或目标。多agent应用场景在软件行业开发、智能生产、企业管理等高度协同的工作中非常有帮助。比如有一家公司就创建了一个多Agent系统，由Agent来扮演产品经理、UI设计师、研发工程师、测试人员、项目经理等角色，甚至可以接一些实际的软件开发任务。

**混合Agent**：这种模式中，Agent系统和人类共同参与决策过程，交互合作完成任务，强调的是人机协作的重要性和互补性。智慧医疗、智慧城市等专业领域可以使用混合Agent来完成复杂的专业工作。比如医生和AI Agent可以共同进行病情诊断，AI Agent负责快速分析病人的医疗记录、影像资料等，提供初步的诊断建议；而医生则可以基于AI Agent的分析结果和自己的专业知识和经验，做出最终的诊断决定。

#### 按决策制定方式分类

**简单反射型Agent**：基于“如果-那么”规则直接响应当前的环境状态，不存储任何历史数据或状态。这种Agent设计简单，反应迅速，但适用范围有限。比如当软件系统发生告警时，就自动向系统维护人员打电话，就是一个简单反射型Agent。

**基于模型的反射型Agent**： 拥有环境的内部模型，能够基于对环境的理解和过去的经验做出更复杂的决策。它能够适应环境变化，处理更复杂的任务。比如Nest的智能温控器，不仅能根据当前温度调节室内气温，还能学习用户的偏好，就是一个基于模型的反射型Agent。

**基于目标的Agent**： 这类Agent的决策方式，从根本上不同于前面描述的条件-动作规则，因为它涉及对未来的考虑。比如智能导航软件，根据用户的起点和目标，结合交通拥堵状况和用户的偏好，输出最佳导航路线。

**基于效用的Agent**： 基于效用的Agent旨在最大化效用功能或价值，精心挑选具有最高预期效用的行动，以衡量结果的有利程度。比如同样是导航到达目标，有的用户需要用时最短，有的用户需要路费最少，那么基于不同的效用，系统就会给出不同的导航结果。

**学习型Agent**： 这些Agent设计用于在未知环境中运行，从自己的经历中学习，并随着时间的推移调整自己的行动。比如AlphaGo就是学习型Agent，从不断的对弈中进行策略调整。

**基于逻辑的Agent**：通常基于一系列逻辑规则，通过推理来解决问题，适合需要高度逻辑判断的场景，例如法律咨询聊天机器人。

LLM大模型和这些Agent的关系就在于，LLM大模型为Agent的后续行动提供了输入和推理。比如LLM大模型上面接了一个基于目标的Agent，那么这个Agent就会从用户的输入中，提取用户的目标和要求，再结合上文提到的子任务分解、反思和完善等动作，逐步完成最终目标。

## 为什么会产生AI Agent？

为什么会产生AI Agent（特指LLM Agent）？我们从两个方面来回答这个问题，技术发展的局限性，以及人和AI的交互性。

### 从技术发展的局限性来考虑

在LLM大语言模型出现以前，一般通过规则和强化学习的方法来让机器智能化的完成一些任务，但是这两种方法各有弊端。

规则的方法是指把复杂的自然语言问题转化为规则符号，往往需要行业专家的介入，缺乏容错能力，一个小的错误就可能导致整个系统的失败。

而强化学习一般是构建策略网络或奖励模型，需要大量样本进行训练，但是收集数据往往成本很高，所以这种方法可行性不大，很难推广开来。

LLM大语言模型出现之后，人们发现LLM大语言模型在逻辑推理、工具应用、策略规划、指令遵循等方面都有非常不错的表现，工程师们开始意识到，将大语言模型作为Agent应用的核心认知系统，可以极大的提高Agent的规划能力。

但是LLM大模型毕竟还无法像人类一样，拥有更深度的规划思考能力、运用各种工具与物理世界互动，以及拥有人类的长期记忆能力。

在这样的背景下，出现了非常多的研究方向，来让Agent逐渐逼近人类，比如前文提到的COT/TOT/GOT、ReAct、Reflexion等技术，提升Agent的Planning能力；比如通过RAG增强检索生成技术，提升Agent的记忆能力；以及ToolFormer、Function Calling等技术，提升Agent的工具使用能力。

### 从人和AI互动的角度来考虑

从人和AI互动的角度，主要经历了三种模式。

最早出现的是Embedding模式，即人类完成大多数工作，AI只是作为某些单点能力，嵌入在人类完成工作的某些节点。比如很典型的SaaS+AI模式，像OCR、人脸识别、语义分析等能力，作为一些提升效率的点，嵌入在SaaS软件里。大多数的工作，还是通过人工操作SaaS软件完成的。

随着大模型的出现，在部分场景下，人类和AI的协同进化到了Copilot模式，即AI作为人类的坚实助手，随时辅助人类的工作。比如Notion AI和微软Copilot，人类在AI的帮助下进行写作，AI随时可以进行内容提示、扩充、修改。

而AI Agent模式，则是将人类与AI的协同进化到了新的高度，人类只是提出任务和目标，然后由AI自主完成大多数工作。所以从人和AI互动的角度来看，AI Agent也是AGI发展过程中的必经之路。


### AI Agent有哪些优势和局限？

对于用户来讲，AI Agent的主要优势包括：

**第一，以任务为导向**。AI Agent脱离了传统 Chatbot 那种闲聊的交互模式，能够弥合语言理解与采取行动之间的鸿沟。直接基于用户输入中所体现出来的意图，自动进行后续的推理和行动，可以大幅提升工作效率。

**第二，自然的交互方式**。由于AI Agent本身以LLM大语言模型为底座，固有的语言理解和语言生成能力，确保了自然无缝的用户交互。

**第三，进化的决策能力**。AI Agent的决策能力依赖于背后的LLM大模型，虽然目前LLM大模型的决策能力还远远不如人类，但这项能力在持续不断的进化。

**第四，灵活的适应性**。在RAG和Function Calling等技术的支撑下，AI Agent可以快速适应各种不同的行业和应用场景，并通过API调用和外部环境产生交互。

但是由于LLM大模型本身固有的局限，这种局限也同样影响了AI Agent。

**第一，可靠性不足**。众所周知，LLM大模型容易出现幻觉和不一致性，将多个步骤连起来会进一步加剧可靠性问题，从而难以获得用户信任。举个例子，假设每个步骤LLM的可靠性是95%，如果一个任务需要被分解到5步以上，那么最终的可靠性将不到80%，这会大大限制AI Agent在一些Critical场景下的应用。

**第二，法律问题**。对于企业对外输出的AI Agent，企业可能要对其产生的错误负责。比如，最近一位客户因为被加拿大航空公司的聊天机器人误导而延误航班，最终由加拿大航空予以赔偿。

**第三，性能和成本**。GPT-4、Gemini-1.5在推理和function calling的表现不错，但仍然较慢且成本高，特别是需要进行循环调用和自动重试时。

对于AI Agent可靠性的问题，其中一个解决方案是Agentic Workflow，即借助人工经验进行任务分解、配置执行任务。AI Agent在整个workflow中，更多起到意图识别、检索、归纳、分类的作用。

比如通过workflow创建一个输出财务分析报表的AI Agent，由人类告诉AI Agent，当接收到分析某家公司的财务报表时，先去某财务网站搜索该公司的财务报表，然后下载报表数据进行本地化存储，再提取特定字段的数据进行计算和同比，最后再以自然语言的方式输出财务分析报告。

### 企业和个人为什么要关注AI Agent？

企业用户通常面临更加复杂的业务需求，有更明确的业务场景、业务逻辑以及更多行业数据和行业知识的积累，非常适配 Agent 自主性、决策与执行、工具使用等特点，这让企业端领域成为 Agent 施展能力的绝佳舞台。

同时，AI Agent可以用工程化的思想对抗个体工作的不确定性，过往的SOP、PDCA、OKR等管理方法可以与AI Agent进行适配，完成管理工作的科学升级。

因此，企业需要关注AI Agent，结合企业所在的行业特点以及自身的业务属性，通过AI Agent提升业务效率。在企业的供应链、产品研发、市场营销、内部办公等环节，AI Agent都有非常多的应用场景。

比如在供应链环节，AI Agent可以应用在智能配补货、原料自动下单、库存优化、供应商协同、合同自动审查等场景。在产品研发环节，AI Agent可以应用在产品成分分析、新品研发建议、产品设计出图等场景。在市场营销环节，AI Agent可以用于智能客服、精准推荐、营销创意制作、广告智能投放等场景。

我们再来看AI Agent对于个人的影响。虽然到目前为止，面向C端用户，市场上还没有出现killer级的C端应用，包括 OpenAI 的 GPTs，其实只是用于特定知识库或数据的 Chatbot。但是从AI的长期发展趋势来看，AI Agent一定会在越来越多的场景进行渗透。

同时，个人作为企业端的工作者，AIAgent对个人在工作效率上带来的提升，也是显而易见的。利用AI Agent武装自己，让工作和学习效率更上一级台阶。

对于个人来讲，未来可能只有两种人，驱动Agent的人，和被Agent驱动的人。


## AI Agent的发展历程是怎样的？AI Agent未来的发展趋势是怎样的？

### AI Agent的发展历程

#### 阶段一，LLM大模型时代之前的Agent

Agent这一概念其实要早于LLM大模型，最早可以起源于马文明斯基在80年代出版的《智能社会》这本书，Agent理论在LLM大模型出来之前，也已经被学术界研究了很多年。

AI Agent的核心三大组成部分，Perception、Brain和Action，其中最关键的部分就是具备记忆、规划和推理能力的Brain。在大模型出现之前，Agent的技术始终面临天花板，无法取得实质性的进步，其核心就是缺乏具备规划和推理能力的Brain，且这种Brain还需要具有良好的通用性和泛化性。

在LLM大模型出现之前，比较知名的垂直领域 Agent 的例子比如 Alphago，它有感知环境、思考决策、采取行动的闭环逻辑。还有DeepMind的Agent57，使用强化学习方式让Agent学习打游戏，以及OpenAI玩“躲猫猫”的多智能体。

在这一阶段，常规的Agent更多采用结构化固定模式，通过实现固定算法流程来完成一些自动化任务。而大模型为Agent带来了灵活性，使其可以应对人类在脑力劳动中面临的各种复杂的长尾任务，进一步实现体力和脑力任务的全面自动化。

LLM大模型是第一个可以自主学习并拥有广泛知识的AI模型，以LLM大模型作为Brain武装起来的AI Agent，开始迅速发展。

#### 阶段二，Prompt工程

在LLM大模型刚问世的时候，大家都喜欢Prompt工程。用户通过描述角色技能、任务关键词、任务目标及任务背景等信息，告诉大模型需要输出的格式，然后大模型进行输出。

用户们也充分发挥自己的聪明才智，发展了各种各样的Prompt工程的玩法，如角色扮演、零样本提示和少样本提示。比如在少样本提示下，用户只需要给出少量示例，大模型就能学习到示例背后的逻辑，从而给出正确的答复。

当任务过于复杂时，超出了单一 Prompt 的能力时，可以通过分解任务，构建多 Prompt 来协同解决。最常见的 Prompt 协同形式就是提示链 Prompt Chain，Prompt Chain 将原有需求进行分解，通过用多个小的 Prompt 来串联或并联，共同解决一项复杂任务。

#### 阶段三，大模型插件

虽然Prompt工程很强大，但是仅凭Prompt工程根本无法满足人们日益增长的复杂需求。由于大模型本身的诸多缺陷，如不能及时更新知识，上下文长度有限等等，工程师们开始给大模型加入插件。

比如引入向量数据库，对某些特定的专属数据进行切片、分块和向量化，然后把数据索引进向量数据库。当用户进行输入时，先通过数据召回找到最匹配的数据分块，再提交给大模型做Prompt工程，这样就可以使用到最新的和最准确的知识。这就是检索增强生成RAG，Retrieval-Augmented Generation。

同时，为了让大模型更好地和物理世界交互，工程师们尝试让 GPT 调用函数和使用工具。一系列关于工具使用的实践开始出现，比如Toolformer和API Bank，ChatGPT也推出了自己的插件体系。

#### 阶段四，任务分解与反思

大模型在一些简单的任务上取得了还不错的结果，人们开始往更深处探索大模型的智能，尤其是处理复杂问题上的能力，这就涉及到了对复杂任务的分解，以及在行动过程中的反思。

**(1) 思维链COT**

当我们对LLM这样要求「think step by step」，会发现LLM会把问题分解成多个步骤，一步一步思考和解决，能使得输出的结果更加准确

**(2) COT-SC**

一个CoT有时可能出现错误，我们可以让Agent进行发散，尝试通过多种思路来解决问题，然后投票选择出最佳答案，这就是CoT-SC。

**(3) 思维树TOT**

思维树TOT是对思维链CoT的进一步扩展，在思维链的每一步，推理出多个分支，拓扑展开成一棵思维树。使用启发式方法评估每个推理分支对问题解决的贡献。选择搜索算法，使用广度优先搜索（BFS）或深度优先搜索（DFS）等算法来探索思维树，并进行前瞻和回溯。


**(4)思维图GOT**

思维树ToT 的方式也存在一些缺陷，对于需要分解后再整合的问题，比如排序问题，排序我们可能需要分解和排序，然后再merge。这种情况下TOT就不行了，可以引入思维图GOT来解决。

当人们发现大模型的推理能力还是不足时，开始试图让模型自身清楚地描述问题，把问题转化为 PDDL （Planning Domain Definition Language）格式的描述语言，通过调用通用规划器来解决规划问题，再把解决方案转化为可执行的动作，以更好地逻辑推理和规划等任务。这就是LLM+P

上面几种思路都是在解决任务分解问题，工程师们也想到了很多解决大模型反思和完善自身行动的思路。

首先是ReACT，全称是Reasoning-Action，这种模式是让大模型先进行思考，思考完再进行行动，然后根据行动的结果再进行观察，再进行思考，这样一步一步循环下去。这种行为模式基本上就是人类这样的智能体主要模式。

然而，工程师觉得这样仍然不够，他们希望大模型在完成每一个任务后，能够积累经验和教训、因此产生了借鉴强化学习思路的”反射”机制，反射机制能够让机器记住每一次任务的完成情况，无论效果好坏，以供未来参考，提升模型的性能。这就是Reflecxion。

#### 阶段五，Agent问世

随着各项基础设施的逐步完善，更大的变革轰然袭来，这就是Agent。2023年4月AutoGPT横空出世正式宣告了LLM Agent的来临，短短数周就获得了9万星，赚足了眼球。

AutoGPT 旨在实现对任务的有效管理。生成的任务将会被加入优先级队列中，随后系统会不断从优先队列中选择优先级最高的任务进行执行，整个过程中，任何反馈都会通过记忆进行迭代优化代码

随后，更多的LLM Agent如雨后春笋般爆发出来，比如微软的Jarvis HuggingGPT、专门用于写小说的RecurrentGPT、清华联合面壁推出的双循环机制XAgent、虚拟世界Minecraft中的智能体Voyager等等。

然后，工程师们就想到了Multi-Agent，既然Single Agent已经具备了独立决策和行动能力，如果将多个Agent放到一个环境中，他们之间会碰撞出什么火花呢？

“斯坦福小镇”项目应该是最有名的Multi-Agent项目，在这个虚拟的小镇里，有25 个独立的 AI 智能体在小镇上生活。他们的决策和行动并不是固定写死在系统里面的，每个智能体背后都连接着LLM大模型。他们有工作，会八卦，能组织社交，结交新朋友，甚至举办情人节派对，每个小镇居民都有独特的个性和背景故事。这些角色每天会自己制定计划，参与活动和做事情，还会主动和其他Agent交谈。同时，Agent交谈的内容会被存储在记忆数据库中，并在第二天的活动计划中被回忆和引用，是不是非常像人脑的记忆系统？“斯坦福小镇”项目也涌现出了许多颇有趣味性的社会学现象。

还有一个很著名的Multi-Agent项目叫MetaGPT。这个项目按照软件公司的组织架构，定义了多个AI智能体角色，包括产品经理、架构师、项目管理员、工程师和测试人员等角色。各角色之间通过相互协作，基本可以胜任完成500行左右代码的小工程了。随着AI Agent的进一步强大，在未来每个人完全可以开一家虚拟公司，自己承接物理世界的真实需求，然后交给虚拟公司的员工完成，非常具有想象空间。

这就是AI Agent到目前为止的大体发展过程，LLM大模型的出现是Agent发展的拐点，Agent的发展速度如火箭般攀升。那么站在现在看未来，AI Agent会有怎么样的发展趋势呢？

### AI Agent的未来发展趋势

其实，目前AI Agent最大的局限就是可靠性不足。因为LLM大模型容易出现幻觉和不一致性，将多个AI步骤连起来会进一步加剧可靠性问题，从而难以获得用户信任。举个例子，假设每个步骤LLM的可靠性是95%，如果一个任务需要被分解到5步以上，那么最终的可靠性将不到80%，这会大大限制AI Agent在一些Critical场景下的应用。

未来，AI Agent的发展，必须首先要解决可靠性不足的问题，而解决可靠性不足的问题，就得从任务分解与反思、记忆优化、Function Calling准确性这几个维度入手。

#### 任务分解与反思

现在的 Agent 只是一个规划器，它负责做规划。但实际上，这个流程中还存在很多未明确的问题，比如是否存在一个内部加工过程，以及这个过程是否透明可控等。

类比我们人类思考的过程，人脑有两套系统，系统1和系统2。系统1是快思考，出自于人类天生的本能，思考时间快，消耗能量少。系统2是慢思考，人类的逻辑能力、推理能力和归纳能力，皆是出自于系统2，而且系统2思考时间慢，消耗能量大。系统2的能力大多数都是人类后天习得的，但是经过不断地刻意练习后，一部分能力也能由系统2转移到系统1，由慢思考变为快思考。

对于任务分别的难题，一种可能的解决办法是将内部加工过程外部化，用系统2包裹起来，使每一步细粒度的思考都可以展现出来。但是具体如何用系统2进行包裹，需要持续关注AI Agent最新的论文和进展。

#### 记忆优化

目前，AI Agent的记忆机制是把所有的信息，以向量数据的方式存储在历史记录里，然后在需要的时候进行召回。这种记忆方式，站在工程化的角度，其实也比较合理，但是在实际使用中，会出现一些问题。

首先，历史记忆会越积越多，当数据量到达一定程度之后，数据召回的速率就会显著下降，从而影响AI Agent的反应速度。其次，在记忆数据库中，一定会存在大量的错误信息，或者不合时宜的信息，但是AI Agent很难判断哪些记忆是需要修正的。

人类的记忆其实是有重塑机制的，人类在获得大量相关的知识后，不会简单地把它们堆积在脑中，而是通过海马体进行重整。比如在我们做梦时，大脑会重新构造这些相关的知识，使得记忆网络变得有序。同时，人类可以主动删除一些不好的记忆，或者错误的记忆，比如很多生活中无关紧要的信息，人脑就会逐渐遗忘掉，从而避免记忆负荷越来越大。

所以在未来，AI Agent一定要优化记忆系统，不能简单的将长短时记忆简化为向量数据库。

#### Function Calling准确性

目前，Function Calling是AI Agent进行工具使用的最主要的手段，可以说AI Agent的执行能力强依赖于大模型的Function Calling能力。但是目前的Function Calling的准确性其实并不理想，表现最好的大模型其准确率也只有86%。

86%意味着什么？

意味着，目前的AI Agent还只能应用在对准确率要求不高、有人类进行兜底的场景，比如撰写论文或调研报告、智能客服等等。对于更加严谨的场景，比如工业、医疗、能源，还难以有AI Agent的用武之地。

还意味着，如果AI Agent需要执行一连串的任务，哪怕只有5个环节，整体流程的准确率将下降到不足30%，即系统不可用。

所以在未来，AI Agent一定要提升Function Calling的准确性，或者有更准确的API调用方式。只有当准确率达到99.99%以上时，AI Agent才能在更为广阔的工业界生根发芽。

#### 多模态与世界模型

除了以上三个维度之外，还有一个非常关键的点，即多模态和世界模型。

在漫长的进化历史中，生物神经网络从简单的条件反射逐渐进化到今天的主动预测，我们已经可以在大脑中构建世界模型，进行强大的推理和分析。比如当我们看到晚霞时，就会知道明天大概率是个晴天；比如当我们感知到建筑发生摇晃时，就知道很有可能发生了地震，需要赶紧去一个安全的地方。

现在的大模型主要是通过语言进行交互，这样显然是不够的。如果要进一步理解世界，一定需要多模态输入，包括视觉、听觉、传感器等等。因此，未来的AI Agent一定会更多和物理实体相结合，比如将AI Agent集成进入机器狗，训练其进行救援任务。在这个过程中，对于时间的认知、身体运动的控制也需要集成到AI Agent里面去。

AI Agent的发展速度太快了，每个月甚至每周，都有新的研究成果、新的产品问世。我们能做的，就是躬身入局，时刻关注大模型和Agent的发展。

## AI Agent领域都有哪些核心玩家

### 从AI Agent框架本身

按照AI Agent的框架，将整个Agent产业自下而上分成了三层：最下面为用于智能体运营（AgentOps）的模块插件层，中间为程序应用层（Applications），最上面为服务层（Services）。整个划分非常清晰。

#### AgentOps运营层

最下面的AgentOps，采用了AI Agent的组成架构，即智能（Intelligence，负责Planning）、记忆（Memory）、工具使用（Tools & Plugins）。此外，还有多智能体环境和协议（Multi-agent playgrounds and protocols）、监控/安全和预算（Monitoring,security and budgetary）、以及智能体运营市场（AgentOps marketplace）等辅助模块。

- **智能（Intelligence）**：智能体的“大脑”，背后是LLM大模型，负责任务创建和规划，这里我们能看到OpenAI GPT、Claude、HuggingFace等耳熟能详的名字。大模型质量、可靠性和成本，将是这部分玩家的制胜关键。
- **记忆（Memory）**：用于获取、存储、保留和检索数据，向量数据库是其中的关键。这里的玩家包括 Pinecone、Chroma以及像Perplexity AI一样具有集成优势的Text to SQL 初创公司。记忆容量、读取速率、尤其是召回准确率，将是这部分玩家的关键因素。
- **工具和插件（Tools and plugins）**：能够为Agent提供API和技能库，用于Agent和外部系统与环境进行交互，例如搜索查询、发送邮件等。典型的包括API-Bank、Toolformer、以及部分大模型自带的function calling能力。
- **多智能体环境和协议**：这部分主要用于智能体和智能体的通信协议，包括PumaMart、SIM Gen Agents和E2B。
- **监控、安全和预算**：这部分主要解决智能体在LLM大模型、通信协议、安全安保方面的问题，也应该受到重视，安全是任何场景下使用Agent的前提。
- **智能体运营市场**：主要用于Agent框架的发布、开源Agent的共享等。这块最主要的玩家是HuggingFace和Github，还有FinGPT、BabyAGI等开源框架。

#### Agent应用层

Agent应用程序层包括通用应用（General purpose）和行业应用（Business industry）

通用应用主要偏个人应用场景，比如个人生活助理、商务助理、日常工作助理等等。典型的产品包括Embra AI、Adept AI、Cognosys AI。

行业应用主要偏业务垂直场景，比如编程、营销、金融、供应链等等。典型的产品包括Quill AI、Octain AI等等

#### Agent服务层

Agent服务层主要包括智能体搭建平台和智能体市场。

智能体搭建平台是一种低代码平台，支持普通用户通过简单的配置搭建属于自己的Agent，大幅降低AI Agent的创建门槛。目前智能体搭建平台受到了很多大厂的青睐，因为大厂很难一开始基于某些垂类场景开发Agent应用，因此智能体搭建平台成为最实际的选择。比如微软的Autogen、百度智能体平台、字节Coze、腾讯元器等等。

### 从AI Agent行业场景

E2B出品的这份AI Agent行业全景图是相对比较完整的。整张图有两个维度，第一个维度是开源和闭源，第二个维度是AI应用，包括了Coding、Productivity、General Purpose、HR、Data Analysis、Business Intelligence、Science、Research、Design、Marketing、Finance等细分领域。

每个细分领域具体的玩家就不一一列举了，大家可以详细参考下图。另外，这张图是持续更新的，通过这个地址 https://github.com/e2b-dev/awesome-ai-agents ，大家就能看到最新的进展，以及E2B对每个玩家的详细介绍

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202505312211535.png)

### 国内AIAgent生态

目前国内的AI Agent发展也十分迅猛，整个AI Agent行业分为三层。

最底层是算力层，包括像阿里云、AWS、华为云这类提供底层GPU算力的云厂商。

中间是平台框架层，包括面向企业业务工作流场景的企业级AI Agent平台，比如钉钉、汇智智能、澜码科技。以及面向个人开发者或普通用户的AI Agent平台，比如百度文心智能体平台、阿里ModelScope、字节扣子等。

最上层是垂直应用层，比如专注于金融行业的Easy Link、招聘行业的用友和Moka、营销领域的BetterYeah。

对于普通的创业者或创业团队来说，肯定没有足够的资源投入大模型赛道，但是站在大模型的肩膀上，选择一个相对垂直的领域做AI Agent，服务于企业客户的具体业务流程和场景，是更加切实可行的选择。


## AI Agent都有哪些可落地的场景

AI Agent的发展正在以前所未有的速度改变我们的生活和工作方式。接下来我们从行业视角来分析一下，在具体的行业中AI Agent都有哪些可落地的场景。

###  电商&零售

- **个性化推荐系统**：将用户的历史浏览数据、购买数据以及当下和AI的上下文数据，作为输入给到AI Agent，Agent自动预测用户在未来对各类商品的购买率，进行重排后输出预估购买率最高的TopN商品，实现个性化的产品推荐。
- **个性化营销系统**：将用户历史上在各个营销渠道的触达和点击数据，结合本次营销活动的营销内容，作为输入给到AI Agent，Agent自动预测每个用户在每个营销渠道（比如短信、外呼、小程序、公众号等）的预估点击率，从而实现自动化和个性化的营销活动，提高用户参与度和品牌曝光度。
- **智能客服**：通过提前构建企业专属知识库，AI Agent 可以自动回答用户的咨询，处理订单问题和退货请求。相比传统智能客户，AI Agent可以支持用户灵活多样的问题，不用局限于传统的Q&A模板，可以大幅节省准备问答对的时间，提升智能客服的准确率。
- **内容生成**：在电商场景中，经常会涉及到商品封面图、海报、商品详情页、营销文案等内容的生成。传统的做法都需要人工拍摄和撰写，而在AI Agent的助力下，使用者只需要告诉Agent关键词，比如商品类型、内容形态、内容主题和风格等，AI Agent可以自动完成。
- **需求预测**：将过去一段时间内，各个品类的销量数据、促销活动信息、天气信息等数据，作为输入给到AI Agent，Agent预测未来一段时间内的销量，从而帮助企业提前做好配货。
- **库存管理**：将历史各个品类的订单数据，各个供应商的供货数据，比如供货周期、供货价格，作为输入给到AI Agent，AI Agent预测每个品类的安全库存，并在商品库存预警时，自动发起采购流程。
- **价格优化**：AI Agent还可以使用爬虫工具获取市场动态、竞争对手定价和用户行为，经过数据分析后，为电商企业提供动态定价建议。这种实时的价格调整策略有助于最大化利润和竞争力。

### 制造业

- **质量控制**：用摄像头捕捉生产线上各类零件和成品的图像，将图片或视频传递给AI Agent，Agent利用计算机视觉技术对图像进行分析，自动检测产品缺陷。当检测到存在缺陷的零件时，可以发送通知给产线检查员，甚至可以直接操作机械臂取出缺陷品。
- **生产线优化**：生产线流程是一个标准的workflow，workflow的每个环节都有明确的步骤、检查事项和执行动作。在这个过程中，可以利用Agentic Workfow，明确告知Agent要做的事项，将更多过去需要由人工重复执行的过程，交给AI Agent，从而提升生产效率。
- **产品设计与开发**：AI Agent 可以协助设计师和工程师进行产品设计，比如设计师输入设计和尺寸的要求，AI Agent直接进行线稿设计；或者设计师提供线稿设计后，AI Agent输出渲染效果图，向设计师提供多种设计创意，从而缩短产品开发的周期。
- **能源消耗管理**：AI Agent能够接收机器或设备上传感器的数据，例如温度、电压、电流等等，和数据库中正常的设备运行数据进行比对，从而对设备的运行情况进行监控和预警。例如，当某个设备因电源老化出现电压异常时，AI Agent可以提早识别，并预警给工厂设备的维修人员。
- **供应链管理**：和电商行业的需求预测和库存优化类似，AI Agent可以预测产品未来一段时间的销量，同时根据历史订单和采购数据预测最优的安全库存，以及通过预警机制进行供应链上下游的协同，帮助企业更好地应对市场需求的波动和变化。
- **工艺改进**：AI Agent 还可以通过分析生产过程中的数据，比如在不同环境和参数下生产出来的产品的差异性，从而进行工艺参数的优化，提升产品质量和生产效率

### 医疗行业

- **疾病预测和预防**：通过历史积累的患者健康数据，比如血糖、血氧、白细胞、红细胞等大量指标数据，AI Agent可以学习到各项指标与疾病之间的相关性，对于像糖尿病、心脏病等疾病，提前预测病人患此类疾病的风险。
- **药物研发**：和疾病预测类似，AI Agent可以分析既有药物中的各种化学和生物成分，结合每种药物的药效，从而预测新的化学和成分组合之后的药性，加速新药的发掘和开发，大幅降低研发成本和时间。
- **智能问诊服务**：在LLM大模型基础上，通过RAG技术挂载医疗知识库，将AI Agent训练成为医疗领域专才，为患者提供7\*24小时的在线医疗咨询服务，根据患者的问题描述，还能提供初步的诊断建议。这样既可以提升患者的就医体验，也能减轻医生的工作负担。
- **医疗影像分析**：通过机器视觉技术，AI Agent 能够辅助医生分析 X 光、MRI、CT 等医疗影像，快速识别出患者是否有异常情况，如肿瘤、肺炎、骨折等，提高诊断的准确性和效率。
- **医疗教育和培训**：当AI Agent挂载了专门的医学知识库之后，还可以作为医疗教育的工具。比如AI Agent可以模拟患者向医学院的学生提问，根据学生的回答，自动分析学生的学习情况，并指出学生的错误和不足，并引导学生进行专门的医疗课程学习。

AI Agent在各个行业都有非常多的应用场景，除了上述介绍的电商、制造、医疗之外，还包括金融、物流、能源、人资、旅游、教育等等行业，就不在文章里一一赘述了。


## 如何实现AI Agent？AI Agent包括哪些系统模块？

从结构上来说，一个AI Agent包括三个部分：
- Perception（输入）：AI Agent通过文字输入、传感器、摄像头、麦克风等等，建立起对外部世界或环境的感知。
- Brain（大脑）：AI Agent最重要的部分，包括信息存储、记忆、知识库、规划决策系统。
- Action（行动）：基于 Brain给出的决策进行下一步行动，对于AI Agent来说，行动主要包括对外部工具的API 调用，或者对物理控制组件的信号输出

接下来，我们就按照这个模块划分，逐级下钻，详细介绍搭建一个完整的AI Agent系统，都需要哪些步骤。

### Perception（输入）

AI Agent应该能够接收多种信息输入，从最简单的文本和语音，到更复杂的图片、视频和传感器数据。因此从产品功能角度，AI Agent应该具备以下能力。

- **文本输入**：这是最常见的AI Agent接收用户指令的方式；如果要求AI Agent具备chat能力，还需要有基础的对话框，便于和用户进行自然语言交互。
- **语音输入**：本质上还是文本输入，只需要在输入环节额外增加一层ASR转TTS，将语音转化为文本。
- **文件上传**：在特定场景下，AI Agent需要对用户上传的文档进行分析，例如财报智能解读、合同智能审查等，需要具备文件上传功能
- **图片和视频输入**：AI Agent有时候需要处理图片，比如进行图像处理、医学影像分析。视频输入本质上也是图片输入，在输入层对视频流进行切片，比如线下门店监控、视频信息提取等场景。
- **传感器输入**：在制造业和能源行业，会要求AI Agent进行设备状态监控和预警，这个时候就要求AI Agent具备传感器对接能力，接收来自设备的温度、电压、电流等数据。

现在的大模型主要是通过语言进行交互，这样显然是不够的。如果要进一步理解世界，一定需要多模态输入，包括视觉、听觉、传感器等等。因此，未来的AI Agent一定会更多和物理实体相结合，比如将AI Agent集成进入机器狗，训练其进行救援任务。在这个过程中，对于时间的认知、身体运动的控制也需要集成到AI Agent里面去。

当然，在实际产品设计中，需要根据实际AI Agent的应用场景来设计其支持的输入类型。

### Brain（大脑）

#### 记忆模块

记忆，在Agent系统中扮演着十分重要角色，负责存储和组织从环境中获取的信息，以指导未来行动。记忆模块通常包含短期记忆和长期记忆两个部分。

短期记忆暂存最近的感知，通常是和AI Agent对话的上下文，这块相对比较简单，直接将短期记忆存入缓存即可。

困难点在于长期记忆，长期记忆的容量要远远大于短期记忆，如何让AI Agent从长期记忆中快速且准确地回忆起相关内容，是在这一模块需要重点解决的问题。

要实现良好的长期记忆性能，有三个重要的技术依赖项，向量数据库、RAG技术和Rerank技术。

**a.向量数据库**

AI Agent的记忆系统，不能采用传统数据库进行存储，必须采用向量数据库。像MySQL这样的传统数据库，在AI应用场景中，有两个非常致命的缺陷。

第一个缺陷是语义搜索的缺失，比如用户想在文档中找到表达“精彩万分”或“激动人心”的段落，传统数据库是肯定做不到的，传统数据库只能基于确定的“关键词”进行精确匹配或者模糊匹配。

第二个缺陷是非结构化数据处理不足，对于图像、音频和视频等非文本内容，传统数据库无法进行有效的内容搜索。比如用户想找到《星球大战》电影中天行者出现的片段，就无法通过传统数据库实现。

而向量数据库是一种特殊的数据库，它以多维向量的形式保存信息，代表某些特征或质量。根据数据的复杂性和详细程度，每个向量的维数可能相差很大，从几维到几千维不等。这些数据可能包括文本、图像、音频和视频，通过机器学习模型、单词嵌入或特征提取技术等各种流程转化为向量。

向量数据库的主要优势在于，它能够根据数据的向量接近度或相似度，快速、精确地定位和检索数据。这样就可以根据语义或上下文的相关性进行搜索，比如根据旋律和节奏搜索出特定的歌曲、在电影中搜索浪漫的片段、在文档中找出意图相近的段落等等。


**b. 检索增强生成RAG**

RAG（Retrieval Augmented Generation），其主要作用类似于搜索引擎，找到用户提问最相关的知识或者是相关的对话历史，并结合原始提问，创造信息丰富的prompt，指导LLM大模型生成更准确的输出。简而言之，RAG就是给大模型它原本数据集中没有的知识。

RAG技术产生最大的原因，是为了克服大模型的幻觉问题，以及在专业领域知识理解较差的缺陷。

RAG可分为5个基本流程：知识文档的准备、嵌入模型、向量数据库、查询检索和生产回答。

现实场景中，我们面对的知识源可能包括多种格式，如Word文档、TXT文件、CSV数据表、Excel表格，甚至图片和视频。因此需要使用专门的文档加载器（例如PDF提取器）或多模态模型（如OCR技术），将这些丰富的知识源转换为大语言模型可理解的纯文本数据，然后开启RAG的五个核心步骤。

**第一步，文档切片/分块**：在企业级应用场景中，文档尺寸可能非常大，因此需要将长篇文档分割成多个文本块，以便更高效地处理和检索信息。分块的方式有很多种，比如按段落、按内容或者其他特殊结构。同时，需要注意分块的尺寸，如果分块太小，虽然查询更精准，但召回时间更长；如果分块太大，则会影响查询精准度。

**第二步，嵌入模型**：嵌入模型的核心任务是将文本转换为向量形式，这样我们就能通过简单的计算向量之间的差异性，来识别语义上相似的句子。

**第三步，存入向量数据库**：将文档切片和嵌入模型的结果存储进入向量数据库，上文介绍了向量数据库，此处不再赘述。

**第四步，用户查询检索**：用户的问题会被输入到嵌入模型中进行向量化处理，然后系统会在向量数据库中搜索与该问题向量语义上相似的知识文本或历史对话记录并返回，这就是检索增强。

**第五步，生成问答**：最终将用户提问和上一步中检索到的信息结合，构建出一个提示模版，输入到大语言模型中，由大模型生成最终的结果并返回

**c. 内容重排技术Rerank**

在RAG技术中，也存在一些局限性，比如使用ElasticSearch的retrieval召回的内容相关度有问题。多数情况下score最高的chunk相关度没问题，但是top2-5的相关度就很随机了，这是最影响最终结果的。

ElasticSearch使用HNSW算法，导致搜索的时候存在随机性，这就是RAG中第一次召回的结果往往不太满意的原因。但是这也没办法，如果你的索引有数百万甚至千万的级别，那只能牺牲一些精确度以换回时间。

这时候我们可以做的就是增加top_k的大小，比如从原来的10个，增加到30个。然后再使用更精确的算法来做rerank，使用计算打分的方式，做好排序。

目前，已经有一些很成熟的Rerank工具可供大家使用，例如Cohere、JinaAI

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202506011105346.jpg)

上图展示了在Agent应用中使用向量数据库的三种场景。

第一种情况，用户的提问不依赖长期记忆，直接从向量数据库中获取关联文档，然后向LLM大模型获取结果。

第二种情况，用户查询一个问题，无法直接从向量数据库获取结果，需要先从长期以及中获取对应的知识块，再向LLM大模型获取结果。

第三种情况，用户进行多次提问，则先检查缓存中是否存在类似问题和答案，优先从缓存中查询返回结果；如果缓存中不存在，则向LLM大模型发起请求。

#### 规划模块

规划模块Planning是整个AI Agent中最核心最关键的部分，Agent会把大型任务分解为子任务，并规划执行任务的流程。同时Agent还会对任务执行的过程进行思考和反思，从而决定是继续执行任务，还是判断任务完结并终止运行。

子任务分解主要包括思维链COT、思维树TOT、思维图GOT、LLM+PDDL等方法；反思主要包括ReAct、Reflection、Multi-Agent等方式。

接下来，我们从产品设计的维度，来看一下比较主流的Planning设计模式。

**a. ReAct**

最容易理解的Planning模式，ReAct本质上就是把融合了Reasoning和Acting的一种范式，推理过程是浅显易懂，仅仅包含thought-action-observation步骤，很容易判断推理的过程的正确性，使用ReAct做决策甚至超过了强化学习。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202506011108025.jpg)

ReACT的主要特性是同步推理Reasoning和行动Acting。比如在上图中，抛出一个问题，关于最初的远程控制苹果的设备有哪些。1a中的回答是直接的；1b的回答是基于思维链CoT方式，能够一步一步进行思考，最初只得出了iphone、ipad、ipod、itouch；1c的回答是只基于行动，比如先搜索Apple Remote，然后根据结果继续搜索Front Row软件，直接就得出了答案，但是这个答案并不是想要的；在1d中，使用了ReACT方式，结合了思考Thoughts和行动Acting，使得得出的结论更加趋于正确结果。

**b. Basic Reflection**

Basic Reflection可以类比于左右互博。左手是Generator，负责根据用户指令生成结果；右手是Reflector，来审查左手的生成结果并给出建议。在左右互搏的情况下，Generator生成的结果越来越好，Reflector的检查越来越严格，提供的建议也越来越有效。

**c. Reflexion**

Reflexion本质上是强化学习，可以理解为是Basic reflection 的升级版。Reflexion机制下，整个架构包括Responder和Reviser，和Basic Reflection机制中的Generator和Reflector有点类似。但不同之处在于， Responder自带批判式思考的陈述，Revisor会以 Responder 中的批判式思考作为上下文参考对初始回答做修改。此外，Revisor还引入了外部数据来评估回答是否准确，这使得反思的内容更加具备可靠性。

**d.REWOO**

REWOO的全称是Reason without Observation，是相对ReAct中的Observation 来说的。ReAct普遍有冗余计算的问题，冗余会导致过多的计算开销和过长的Token使用。而在ReWOO中，使用模块化解耦，完成预测性推理和工具执行，token使用效率要优于ReAct，并提高了在复杂环境下的性能。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202506011114345.jpg)

如上图所示，左侧是以ReAct为主的方法。当User输入Task后，把上下文Context和可能的样本Exemple输入到LLM中，LLM会调用一个目标工具Tool，从而产生想法Thought，行动Action，观察Observation。由于拆解后的下一次循环也需要调用LLM，又会调用新的工具Tool，产生新的Thought，Action，Observation，后续的输入是需要叠加前面的Thought，Action，Observation以及Task，Context，Examplar，从而不断地迭代，完成推理Reasoning，然后生成答案Answer。如果这个步骤变得很长，并且Token很长就会导致巨大的重复计算和开销。

而右侧ReWOO的方法，计划器Planner把任务进行分解，分解的依据是它们内部哪些用同类Tool，就把它分成同一类。在最开始，依旧是User输入Task，模型把上下文Context和Exemplar进行输入，这里与先前有所不同的是，输入到Planner中，进行分解，然后调用各自的工具Tool。在得到了所有的Tool的输出后，生成计划结果Plan和线索Evidence，放到Solver进行总结，然后生成回答。这个过程只调用了两次LLM。

**e.Plan and Execute**

Plan-and-execute这个方法本质上是先计划再执行，即先把用户的问题分解成一个个的子任务，然后再执行各个子任务，最后合并输出得到结果。

架构上包含了规划器和执行器：规划器负责让 LLM 生成一个多步计划来完成一个大任务，代码中有 Planner 和和 Replanner，Planner 负责第一次生成计划，Replanner 是指在完成单个任务后，根据目前任务的完成情况进行 Replan。执行器接受用户查询和规划中的步骤，并调用一个或多个工具来完成该任务。

**f. LLM Compiler**

LLM Comlipler简而言之，就是通过并行Function calling来提高效率。

比如下图的例子，向Agent提问“微软的市值需要增加多少才能超过苹果的市值？”，Planner并行搜索微软的市值和苹果的市值，然后进行合并计算。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202506011117239.png)

LLM Compiler主要有以下组件：

- Planner：流失传输任务的DAG，每个任务都包含一个工具、参数和依赖项列表。
- Task Fetching Unit：调度并执行任务，一旦满足任务的依赖性，该单元就会安排任务。由于许多工具涉及对搜索引擎或LLM的其他调用，因此额外的并行性可以显著提高速度。
- Joiner：由LLM根据整个历史记录（包括任务执行结果），动态重新计划或技术，决定是否响应最终答案或是否将进度重新传递回Planner。

**g. LATS**

LATS，全称是Language Agent Tree Search。说的更直白一些，LATS = Tree search + ReAct+Plan&solve + Reflection + 强化学习。

这种技术受到蒙特卡洛树搜索的启发，将状态表示为节点，而采取行动则视为在节点之间的遍历。LATS使用基于语言模型的启发式方法来搜索可能的选项，然后利用状态评估器来选择行动。

与其他基于树的方法相比，LATS实现了自我反思的推理步骤，显著提升了性能。当采取行动后，LATS不仅利用环境反馈，还结合来自语言模型的反馈，以判断推理中是否存在错误并提出替代方案。这种自我反思的能力与其强大的搜索算法相结合，使得LATS在执行各种任务时表现出色。

LATS有四个主要的步骤：

1. 选择：根据下面步骤中的总奖励选择最佳的下一步行动，如果找到解决方案或达到最大搜索深度，做出响应；否则就继续搜索
2. 扩展和执行：生成N个潜在操作，并且并行执行
3. 反思和评估：观察这些行动的结果，并根据反思和外部反馈对决策评分
4. 反向传播：根据结果更新轨迹的分数

**h. Self Discover**

Self-discover 的核心是让大模型在更小粒度上 task 本身进行反思，比如前文中的 Plan&Slove 是反思 task 是不是需要补充，而 Self-discover 是对 task 本身进行反思。

在self-discover机制下，主要有三个组件。Selector负责从众多的反省方式中选择合适的反省方式；Adaptor使用选择的反省方式进行反省；Implementor则负责在反省后进行重新 Reasoning。

### Action（行动）

Action环节负责AI Agent和物理世界的交互，这里主要介绍两种执行机制，Function Calling和API Bank。

#### Function Calling

Function calling指的是大模型调用特定函数的能力，这些函数可以是内置的，也可以是用户自定义的。在执行任务时，模型会通过分析问题来决定何时以及如何调用这些函数，例如大模型在回答数学问题时，就会使用内部的计算函数来得出答案。

Function Calling 机制主要由以下四个关键组件构成：

- 函数定义：预先定义可调用的函数，包括名称、参数类型和返回值类型等。
- 函数调用请求：用户或系统发出的调用请求，包含函数名称及所需参数。
- 函数执行器：实际执行函数的组件，可能是外部的 API 或本地逻辑处理器。
- 结果返回：函数执行完毕后，返回结果给 ChatGPT，继续对话

举个实际的例子，比如我们询问大模型，“人工智能相关股票，市盈率最低的是哪几个？最近交易量如何？”

- 第一步，准备API接口和认证信息，确定用于获取股票信息的API接口URL，获取并准备好API密钥或其他认证信息。
- 第二步，定义函数以获取市盈率最低的人工智能股票。需要编写一个函数，该函数接受API接口URL和API密钥作为参数。在函数内部，构造请求参数，指定股票分类为人工智能，按市盈率升序排列，并限制返回结果的数量；发送HTTP GET请求到API接口，并传入构造好的请求参数和API密钥；解析响应内容，提取市盈率最低的股票列表信息，返回市盈率最低的股票列表。
- 第三步，定义函数以获取股票的最近交易量。再编写一个函数，该函数接受API接口URL、API密钥和股票代码作为参数；构造特定于股票代码的API请求URL；发送HTTP GET请求到构造好的URL，并传入API密钥；解析响应内容，提取交易量信息，并返回交易量信息。
- 第四步，调用函数并处理结果。调用步骤2中定义的函数，获取市盈率最低的人工智能股票列表；调用步骤3中定义的函数，获取该股票的最近交易量信息；遍历股票列表，对于每只股票，打印或存储获取到的信息，包括股票代码、市盈率和最近交易量。

但是，大家需要注意的是，目前大模型的Function Calling可靠性还非常不足，根据行业对各个大模型的测试结果来看，Function Calling准确性最高的也只有86%，大大限制了AI Agent和现实世界的交互。至少，以目前的水平来看，比较critical的场景下使用Function Calling还是非常受限的。

#### API Bank

API-Bank 模拟真实世界并创建了包含 53 个常用工具的 API 库，例如搜索引擎、播放音乐、预订酒店、图像描述等，供 LLMs 调用。还包含了 264 个经过人工审核的对话、568 个 API 调用，来评估模型在给定的对话语境中，使用 API 完成用户需求的表现。

API-Bank 将测试分为三个级别。

- 级别1：评估 LLMs 正确调用 API 的能力。在给定 API的用法描述和对话历史的前提下，模型需要判断是否调用 API、正确地调用 API、获得 API 调用结果后正确的回复用户。
- 级别2：进一步评估 LLMs 检索 API 的能力。在测试开始时，模型仅被告知 API 检索系统的用法，任何对话中需要用到的特定 API 的信息都不可见。LLMs 必须根据对话历史判断用户需求，关键词搜索可能能够解决用户需求的 API，并在检索到正确的 API 后学习如何使用 API。
- 级别3：评估 LLMs 规划多个 API 调用的能力。在这个级别中，用户的需求可能不明确，需要多个 API 调用步骤来解决。例如：“我想从上海到北京旅行一周，从明天开始。帮我规划旅行路线并预订航班、门票和酒店”。LLMs 必须推断出合理的旅行计划，基于计划调用航班、酒店和门票预订 API 来完成用户需求。

#### Agent市场

Agent除了可以调用API之外，还可以调用其他成熟的Agent。比如完成一份关于AI Agent的市场调研报告，可以先调用专门做市场调研的Agent，输出市场调研的关键信息；再调用专门做PPT的Agent，将关键信息整理成可用于汇报的PPT形式。

因此，对于一个Agent平台来说，除了具备Agent搭建能力之外，拥有一个公开的、可供调用的Agent市场也是非常有必要的。

### Workflow模块

为什么会产生workflow？

因为LLM大模型本身存在“不确定性”，即无论是大模型的规划能力、还是工具调用能力、抑或是自然语言输出，都存在比较强的不可控性。因此，需要对AI Agent的行动增加一定程度的限制，来保障AI Agent不要out of control。尤其是在严谨的企业级应用中，更需要AI Agent的可控和准确。

在这样的背景下，Agentic Workflow诞生了。

Agentic Workflow 通过将一个复杂的任务分解成较小的步骤，在整个过程中中融入了更多人类参与到流程中的规划与定义。它减少了对 Prompt Engineering 和模型推理能力的依赖，提高了 LLM 应用面向复杂任务的性能。

下面是字节Coze平台上的工作流编排器的示例，一个快速生成PPT的流程。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202506011126923.jpg)

通常来说，Agentic Workflow主要包含以下关键组件

- **开始节点**：每一个工作流都需要一个开始节点，在开始节点内定义输入变量支持文本、段落、下拉选项、数字、文件。配置完成后，在工作流执行时会要求输入开始节点中定义的变量值。
- **结束节点**：每一个工作流在完整执行后都需要至少一个结束节点，用于输出完整执行的最终结果。结束节点需要声明一个或多个输出变量，声明时可以引用任意上游节点的输出变量
- **直接回复**：可以在文本编辑器中自由定义回复格式，包括自定义一段固定的文本内容、使用前置步骤中的输出变量作为回复内容、或者将自定义文本与变量组合后回复
- **LLM大模型**：LLM 是Workflow 的核心节点，利用大语言模型的对话/生成/分类/处理等能力，根据给定的提示词处理广泛的任务类型，并能够在工作流的不同环节使用。
- **知识检索**：即记忆模块中介绍的RAG能力，从知识库中检索与用户问题相关的文本内容，可作为下游 LLM 节点的上下文来使用。
- **问题分类**：通过定义分类描述，问题分类器能够根据用户输入推理与之相匹配的分类并输出分类结果。常见的使用情景包括客服对话意图分类、产品评价分类、邮件批量分类等
- **条件分支**：允许用户根据 if/else 条件将 workflow 拆分成多个分支，极大地提升workflow的灵活性。
- **代码执行**：该节点极大地增强了开发人员的灵活性，使他们能够在工作流程中嵌入自定义的 Python 或 Javascript 脚本，并以预设节点无法达到的方式操作变量。比如结构化数据处理、科学计算、数据拼接
- **变量聚合**：变量聚合节点是工作流程中的一个关键节点，它负责整合不同分支的输出结果，确保无论哪个分支被执行，其结果都能通过一个统一的变量来引用和访问。比如问题分类节点后、条件分支节点后的多路聚合
- **参数提取**：利用 LLM 从自然语言推理并提取结构化参数，用于后置的工具调用或 HTTP 请求。比如从论文中提取论文作者 或 论文编号
- **Http请求**：允许通过 HTTP 协议发送服务器请求，适用于获取外部数据、webhook、生成图片、下载文件等情景
- **工具**：包括谷歌搜索、天气查询等内置工具；通过 OpenAPI/Swagger 标准格式导入或配置的自定义工具；已发布为工具的工作流，也可以被其他工作流当做工具来引用

另外，大家需要注意的是，大模型根源的“不太聪明”，是加上workflow也解决不了的。因为工作流解决的并不是意图理解准确率的问题，而是在流程上的被干预后的可控性，吴恩达老师也在红杉的演讲上提到提升大模型本身质量依旧十分重要。

### 安全模块

AI Agent的安全主要包含两方面。一方面是LLM大模型对齐，即大模型本身的输出要符合人类的价值观，不能输出涉黄涉黑涉恐等不合法的言论。另外一方面是Agent的访问和数据安全，确保Agent的数据、模型和决策过程不被未经授权的实体访问或攻击。

LLM大模型对齐是一个非常宏大和复杂的话题，到目前为止，风叔尚未在这块有较多的知识和经验积累，而且大模型对齐更多是OpenAI、LLama等企业才能做的事情，所以此处不做展开。

Agent的数据和访问安全，可以通过SSL协议传输、私有化部署、移动Agent安全信任模型TMMARC等方式，防止Agent数据泄露或被恶意篡改。

一个Agent系统，除了上述五大模块之外，还需要有辅助系统，比如账号权限、系统部署、使用引导等等。















