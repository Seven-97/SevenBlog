---
title: TCP - 流量控制
category: 计算机基础
tag:
  - 计算机网络
---

> 来源：https://www.xiaolincoding.com/ ，Seven进行了部分补充完善

## 重传机制

### 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当**超过指定的时间后**，没有收到对方的 ACK 确认应答报文，就会重发该数据

超时触发重传存在的问题是，超时周期可能相对较长。

### 快速重传
快速重传不以时间为驱动，而是以数据驱动重传。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113882.png)

快速重传的工作方式是**当收到三个相同的 ACK 报文时，可以不用等到超时才重传，会直接重传丢失的报文段**。

快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是重传的时候，是重传一个，还是重传所有的问题

举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？

### SACK 方法
SACK（ Selective Acknowledgment）， 选择性确认。

SACK是**将已收到的数据的信息发送给发送方，这样发送方就可以只重传丢失的数据**。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。
![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113152.png)

### Duplicate SACK
要使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。


## 滑动窗口
TCP 每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。如果是这样传输，那有一个缺点：数据包的往返时间越长，通信的效率就越低。

因此，TCP引入了滑动窗口。窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。

窗口中有部分数据段没有收到ACK，也可以通过下一个ACK进行确认。这个模式就叫累计确认或者累计应答。
![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113209.png)

**窗口的大小**是由接收方的窗口大小来决定的。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。

接收窗口的大小是约等于发送窗口的大小的。因为**滑动窗口并不是一成不变的**。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Windows 字段来告诉发送方。那么这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

## 流量控制
发送方不能无脑的发数据给接收方，要考虑接收方处理能力。

流量控制就是根据接收方的滑动窗口的大小来控制的。

比如服务端繁忙，无法及时的处理掉接收的数据，就会减小接收窗口的大小

## 拥塞控制
**流量控制是避免「发送方」的数据填满「接收方」的缓存**

在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环

**拥塞控制，目的就是避免「发送方」的数据填满整个网络。**

拥塞控制是根据拥塞窗口来实现的，拥塞窗口 cwnd是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的

发送方没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞**。

### 慢启动
慢启动算法：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。

这个大小是指能同时发送数据的数量，比如一开始拥塞窗口为1，表示可以传1个；发送方收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个；以此类推，显然慢启动时的拥塞窗口大小是呈指数增长的

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113813.png)

慢启动算法增长到哪是根据**慢启动门限** ssthresh （slow start threshold）来决定的：
- 当 cwnd < ssthresh 时，使用慢启动算法。
- 当 cwnd >= ssthresh 时，就会使用拥塞避免算法

### 拥塞避免

拥塞避免算法：每当收到一个 ACK 时，cwnd 增加 1/cwnd。

现假定 ssthresh 为 8，当到门限时，当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1
![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113809.png)

就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。当触发了重传机制，也就进入了拥塞发生算法

### 拥塞发生
当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种，两种使用的拥塞发送算法是不同的
- 超时重传
- 快速重传

#### 超时重传
- ssthresh 设为 cwnd/2
- cwnd 重置为 1 （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113123.png)

接着，就重新开始慢启动，慢启动会突然减少数据流，

#### 快速重传
当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

- cwnd = cwnd/2 ，也就是设置为原来的一半;
- ssthresh = cwnd;

进入快速恢复算法

### 快速恢复
算法如下：
1. 拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；
2. 重传丢失的数据包；
3. 如果再收到重复的 ACK，那么 cwnd 增加 1；
如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271113656.png)

也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长