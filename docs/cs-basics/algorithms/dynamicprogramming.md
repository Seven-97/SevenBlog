---
title: 动态规划
category: 计算机基础
tag:
 - 算法
head:
  - - meta
    - name: keywords
      content: 数据结构,动态规划
  - - meta
    - name: description
      content: 全网最全的计算机基础（算法）知识点总结，让天下没有难学的八股文！
---



## 什么是动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。

所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，



例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

动态规划中dp[j]是由dp[j-weight[i]]推导出来的，然后取max(dp[j], dp[j - weight[i]] + value[i])。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。



## 动态规划的解题步骤

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，可以拆解为如下五步曲：**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组



## 01背包问题

题目描述：有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

**所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**



举一个例子：背包最大重量为4。

物品为：

|       | 重量 | 价值 |
| ----- | ---- | ---- |
| 物品0 | 1    | 15   |
| 物品1 | 3    | 20   |
| 物品2 | 4    | 30   |

问背包能背的物品最大价值是多少？



### 二维dp数组

1. 确定dp数组以及下标的含义

对于背包问题，有一种写法， 是使用二维数组，即**dp[i]\[j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

![image-20240427150740757](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271507823.png)



2. 确定递推公式

再回顾一下dp[i]\[j]]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。

那么可以有两个方向推出来dp[i]\[j]，

- **不放物品i**：由dp[i - 1]\[j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i]\[j]就是dp[i - 1]\[j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
- **放物品i**：由dp[i - 1]\[j - weight[i]]推出，dp[i - 1]\[j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1]\[j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]);



3. dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从dp[i]\[j]的定义出发，如果背包容量j为0的话，即dp[i]\[0]，无论是选取哪些物品，背包价值总和一定为0。如图：

![image-20240427151020339](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271510433.png)



在看其他情况。

状态转移方程 dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

dp[0]\[j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 j < weight[0]的时候，dp[0]\[j] 应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，dp[0]\[j] 应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```java
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

此时dp数组初始化情况如图所示：

![image-20240427151108396](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271511457.png)

dp[0]\[j] 和 dp[i]\[0] 都已经初始化了，那么其他下标应该初始化多少呢？

其实从递归公式： dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]); 可以看出dp[i]\[j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。

**初始-1，初始-2，初始100，都可以！**

但只不过一开始就统一把dp数组统一初始为0，更方便一些。如图：

![image-20240427151142267](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271511333.png)



4. 确定遍历顺序

在如下图中，可以看出，有两个遍历的维度：物品与背包重量

![image-20240427151229720](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271512812.png)

那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**。



**理解递归的本质和递推的方向**。

dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]); 递归公式中可以看出dp[i]\[j]是靠dp[i-1]\[j]和dp[i - 1]\[j - weight[i]]推导出来的。



先遍历物品，再遍历背包：

```text
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

dp[i-1]\[j]和dp[i - 1]\[j - weight[i]] 都在dp[i]\[j]的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271514396.png)



先遍历背包，再遍历物品：

```java
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```



先遍历背包，再遍历物品的过程如图：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271515988.png)

**可以看出，虽然两个for循环遍历的次序不同，但是dp[i]\[j]所需要的数据就是左上角，根本不影响dp[i]\[j]公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解。



5. 举例推导dp数组

来看一下对应的dp数组的数值，如图

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271516971.png)

最后的答案就是dp[2]\[4]



### 一维dp数组（滚动数组）

对于背包问题其实状态都是可以压缩的。

在使用二维数组的时候，递推公式：dp[i]\[j] = max(dp[i - 1]\[j], dp[i - 1]\[j - weight[i]] + value[i]);



**其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i]\[j] = max(dp[i]\[j], dp[i]\[j - weight[i]] + value[i]);**

**与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了**，只用dp[j]（一维数组，也可以理解是一个滚动数组）。

这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。



**dp[i]\[j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。



动规五部曲分析如下：

1. 确定dp数组的定义

在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。



2. 一维dp数组的递推公式

dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

dp[j - weight[i]] + value[i] 表示 容量为  【j - 物品i重量】  的背包 加上 物品i 的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）



此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1\][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，

所以递归公式为：

```java
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```

可以看出相对于二维dp数组的写法，就是把dp[i]\[j]中i的维度去掉了。



3. 一维dp数组如何初始化

dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

**这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了**。

那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。



4. 一维dp数组遍历顺序

代码如下：

```java
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

**这里发现和二维dp的写法中，遍历背包的顺序是不一样的！**二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。为什么呢？

**倒序遍历是为了保证物品i只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！



举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

如果正序遍历

- dp[1] = dp[1 - weight[0]] + value[0] = 15

- dp[2] = dp[2 - weight[0]] + value[0] = 30

此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。



为什么倒序遍历，就可以保证物品只放入一次呢？

倒序就是先算dp[2]

- dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

- dp[1] = dp[1 - weight[0]] + value[0] = 15

所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。



**那么问题又来了，为什么二维dp数组遍历的时候不用倒序呢？**

因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1]\[j]计算而来，本层的dp[i]\[j]并不会被覆盖！



**再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

不可以！

因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。



5. 举例推导dp数组

一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271524585.png)



## 完全背包问题

题目描述：有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。



例子同上，但每个物品有无数个，其实也就是可以重复取同一个物品。问背包能背的物品最大价值是多少？



我们知道 01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

```java
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```



但是 **为什么遍历物品在外层循环，遍历背包容量在内层循环？**难道就不能遍历背包容量在外层，遍历物品在内层？

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。

**在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**

因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。



遍历物品在外层循环，遍历背包容量在内层循环，状态如图：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271528379.png)

遍历背包容量在外层循环，遍历物品在内层循环，状态如图：

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404271528597.png)

看了这两个图，大家就会理解，完全背包中，两个for循环的先后循序，都不影响计算dp[j]所需要的值（这个值就是下标j之前所对应的dp[j]）。



先遍历背包再遍历物品，代码如下：

```java
// 先遍历背包，再遍历物品
for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        if (j - weight[i] >= 0) 
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```



## 多重背包问题

题目描述：有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。



多重背包和01背包是非常像的， 为什么和01背包像呢？每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。



例如：

背包最大重量为10。

物品为：

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 2    |
| 物品1 | 3    | 20   | 3    |
| 物品2 | 4    | 30   | 2    |

问背包能背的物品最大价值是多少？



和如下情况有区别么？

|       | 重量 | 价值 | 数量 |
| ----- | ---- | ---- | ---- |
| 物品0 | 1    | 15   | 1    |
| 物品0 | 1    | 15   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品1 | 3    | 20   | 1    |
| 物品2 | 4    | 30   | 1    |
| 物品2 | 4    | 30   | 1    |

毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。



代码如下：

```java
int[] dp = new int[bagWeight + 1];

//先遍历物品再遍历背包，作为01背包处理
for (int i = 0; i < n; i++) {
    for (int j = bagWeight; j >= weight[i]; j--) {
        //遍历每种物品的个数
        for (int k = 1; k <= nums[i] && (j - k * weight[i]) >= 0; k++) {
        	dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]);
        }
    }
}
```









<!-- @include: @article-footer.snippet.md -->     









