---
title: 缓存和数据库一致性问题
category: 系统设计
tag:
 - Redis
 - 缓存
---



## 概述

缓存作为持久化存储（如数据库）的辅助存在，毕竟属于两套系统。理想情况下是缓存数据与数据库中数据完全一致，但是业务最常使用的旁路缓存架构下，在一些分布式或者高并发的场景中，可能会出现**缓存不一致**的情况。

针对如何保证缓存和数据库一致性，引出以下几个问题：
1. 到底是更新缓存还是删缓存？
2. 如果是删缓存，那选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？
3. 为什么要引入消息队列保证一致性？
4. 延迟双删会有什么问题？到底要不要用？
5. ……



## 更新缓存

由于引入了缓存，那么在数据更新时，要想保证缓存和数据库**实时一致性**，就不仅要更新数据库，还要更新缓存

那么数据库和缓存都需要更新，就存在先后的问题：
1. 先更新缓存，后更新数据库
2. 先更新数据库，后更新缓存

由于操作分为了两步，那么就有可能出现 **第一步成功，第二步失败** 的情况

### 第一步成功，第二步失败

#### 先更新缓存，后更新数据库
如果缓存更新成功了，但数据库更新失败了，那么此时缓存中是最 新值，但数据库中是 旧值。虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存失效，就会从数据库中读取到旧值，重建缓存也是这个旧值。

此时数据没有更新成功，显然就会对业务产生影响

####  先更新数据库，后更新缓存

如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是旧值。之后的读请求读到的都是旧数据，只有当缓存 失效 后，才能从数据库中得到正确的值。

这时就会发现，自己刚刚修改了数据，但却看不到修改后的值，一段时间过后，数据才变更过来，显然也会对业务产生影响。

可见，无论谁先谁后，但凡后者发生异常，都会对业务造成影响。那怎么解决这个问题呢？后面详细描述

### 并发场景
#### 先更新缓存，后更新数据库

在并发场景下，假设有线程 A 和线程 B 两个线程，需要更新 X这条 数据，会发生这样的场景：
1. 线程 A 更新缓存（X = 1）
2. 线程 B 更新缓存（X = 2）
3. 线程 B 更新数据库（X = 2）
4. 线程 A 更新数据库（X = 1）

此时，数据库中的 X=1，而缓存中的 X=2 ，出现了缓存和数据库中的数据不一致的现象。

#### 先更新数据库，后更新缓存
同样以上的场景，
1. 线程 A 更新数据库（X = 1）
2. 线程 B 更新数据库（X = 2）
3. 线程 B 更新缓存（X = 2）
4. 线程 A 更新缓存（X = 1）

此时，数据库中的 X=2，而缓存中的 X=1 ，出现了缓存和数据库中的数据不一致的现象。

所以，无论是**先更新数据库，再更新缓存**，还是**先更新缓存，再更新数据库**，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，较大概率会出现缓存和数据库中的数据不一致的现象。

#### 解决方案：分布式锁
通常的解决方案是：加分布式锁

两个线程要修改「同一条」数据，那么每个线程在修改之前，先申请分布式锁，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。

使用分布式读写锁可以完美解决缓存数据不一致的问题，但是想要读数据必须等待写数据整个操作完成。因此，这种方案造成的性能开销有可能会超过引入缓存带来的性能提升。

从**缓存利用率**的角度来看`更新缓存`的方案：当每次数据发生变更，都去更新缓存，但是缓存中的数据实际上并不一定会被马上读取，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。

因此`更新缓存`的方案在未引入分布式锁的情况下，不仅缓存利用率不高、浪费缓存资源，还会造成数据不一致的问题。所以可以考虑删除缓存的方案

## 删除缓存
同样的，删除缓存方案也有两种：
1. 先删除缓存，后更新数据库
2. 先更新数据库，后删除缓存

由于操作分为了两步，那么也有可能出现 **第一步成功，第二步失败** 的情况

### 第一步成功，第二步失败

#### 先删除缓存，后更新数据库
如果缓存删除成功了，但数据库更新失败了，数据库没有更新成功，那下次读缓存发现不存在，则从数据库中读取，并重建缓存，此时数据库和缓存都是旧数据。

此时数据没有更新成功，显然就会对业务产生影响

#### 先更新数据库，后删除缓存

如果数据库更新成功了，但缓存删除失败，那么此时数据库中是最新值，缓存中还是是旧值。之后的读请求读到的都是旧数据，只有当缓存 失效 后，才能从数据库中得到正确的值。

这时就会发现，自己刚刚修改了数据，但却看不到修改后的值，一段时间过后，数据才变更过来，显然也会对业务产生影响。

可见，无论谁先谁后，但凡后者发生异常，都会对业务造成影响。那怎么解决这个问题呢？后面详细描述

### 并发场景
#### 先删除缓存，后更新数据库

开始时 X=1，在并发场景下，假设有线程 A 和线程 B 两个线程，A想要将 X 这条数据修改为 X = 2，B想要读 X 这条数据，会发生这样的场景：
1. 线程 A 先删除缓存
2. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
3. 线程 A 将新值写入数据库（X = 2）
4. 线程 B 将旧值写入缓存（X = 1）

最终，X 在缓存中是 1（旧值），在数据库中是 2（新值），缓存和数据库的数据不一致。

##### 延迟双删
实际上，`先删除缓存，后更新数据库`方案导致缓存和数据库的数据不一致原因在于缓存被写回了旧值。而针对这个方案的解决方法就是延迟双删策略。

在线程 A 删除缓存、更新完数据库之后，先 休眠一会 ，再 删除 一次缓存。伪代码如下：
```
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```
加了个睡眠时间，主要是为了确保线程 A 在睡眠的时候，线程 B 能够在这这一段时间完成「从数据库读取到（旧的）数据，再把（旧的）数据写回缓存」的操作，然后线程 A 睡眠完，再删除缓存。

但是具体睡眠多久其实很难评估，所以这个方案也只是尽可能保证一致性，极端情况下，依然也会出现缓存不一致的现象。

因此，还是比较建议用以下 `先更新数据库，再删除缓存` 的方案。

#### 先更新数据库，再删除缓存
同样的以上的场景：但  X 在缓存中**不存在**，在数据库中 X = 1
1. 线程 A 读取数据库，得到旧值（X = 1）
2. 线程 B 更新数据库（X = 2)
3. 线程 B 删除缓存
4. 线程 A 将旧值写入缓存（X = 1）

最终，X 在缓存中是 1（旧值），在数据库中是 2（新值），缓存和数据库数据不一致。

显然先更新数据库，再删除缓存也是会出现数据不一致性的问题，但是在实际中，这个问题出现的概率并不高。出现这个场景，要同时满足三个条件：
1. 缓存刚好已失效
2. 读请求 + 写请求并发
3. 更新数据库 + 删除缓存的时间（步骤 2-3），要比读数据库 + 写缓存时间短（步骤 1 和 4）

实际上，写数据库一般会先加锁，所以写数据库，通常是要比读数据库的时间更长的。也就是说，通常情况下，更新数据库 + 删除缓存的时间（步骤 2-3），都是要比读数据库 + 写缓存时间 长的

因此，可以说，`先更新数据库 + 再删除缓存`的方案，是可以保证数据一致性的。

## 如何保证两步都执行成功 

前面的方案，都是两步执行的操作，都有可能出现第一步成功，第二步失败的情况，这种情况下都会导致数据问题，导致业务受到影响，因此，需要保证两步都执行成功。

对于单体项目，可使 第一步和第二步 都在同一个事务中执行，使更新数据库和删除缓存是原子性操作
```java
@Transactional //同一个事务中执行，保证同时成功
public Result update(Shop shop){
	Long id = shop.getId();
	if(id == null){
		return "商品id不能为空";
	}
	//更新数据库
	updateById(shop);
	//删除缓存
	redisTemplate(id);
}
```


而对于分布式项目，要保证第二步执行成功，则有两种方案：
1. 重试
2. 订阅MySQL binlog，再操作缓存

### 重试方案
#### 同步重试
同步重试会一直占用这个线程资源，无法服务其它客户端请求。因此同步重试不可取

#### 异步重试
异步重试就是把重试请求写到消息队列中，然后由专门的消费者来重试，直到成功。

> 消息队列也有可能失败？实际上由于消息队列的特性，不会失败：  
> 消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失。  
> 消息队列能保证消息的成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者

方案过程如下：
![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404270808154.png)

### 订阅MySQL binlog，再操作缓存
在Mysql中，当一条数据发生修改时，MySQL 就会产生一条变更日志（binlog），binlog日志用于复制，在主从复制中，从库可以利用主库上的binlog进行重放，实现主从同步。

那么我们就可以伪装成从服务器，对binlog日志进行订阅，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。阿里巴巴开源的 Canal 中间件就是基于这个实现的。

Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。

![](https://seven97-blog.oss-cn-hangzhou.aliyuncs.com/imgs/202404270808358.png)

### 小结
至此，可以得出结论，想要保证数据库和缓存一致性，推荐采用`先更新数据库，再删除缓存`方案，并配合`消息队列`或`订阅变更日志`的方式来做


## 能否保证强一致性
其实在这前面的提到的方案中，说的是 实时 一致性，这个实时一致性是能保证缓存和数据库的最终一致性的，并且接进实时。

但是想让缓存和和数据库强一致，是很难的。最有效的方案`先更新数据库，再删除缓存`也是存在不一致性的可能的，只是概率较低。

要想做到强一致性，那就可以加锁，分布式锁可以完美解决缓存数据不一致的问题，但想要读取数据就必须等待写数据整个操作完成。这就会造成并发上的性能问题

但是，引入缓存的目的就是为了提升性能，决定了使用缓存，那必然就要面临数据一致性问题。性能和一致性无法做到都满足要求。只能尽量降低问题出现的概率，减小对业务的影响

## 总结
1. 更新缓存方案：在并发场景下无法保证缓存和数据一致性，较大概率出现不一致
2. 删除缓存方案：采用`先删除缓存，再更新数据库`方案在并发场景下也有不一致问题，解决方案是延迟双删策略，但这个延迟时间很难评估
3. 删除缓存方案：采用`先更新数据库，再删除缓存`方案，可以尽最大可能保证数据一致性。
4. 针对第二步可能失败的问题，需要配合`消息队列`或`订阅变更日志`的方案来做
5. 性能和数据一致性不能同时满足，一般采用的是最终一致性方案，并尽量降低问题出现的概率。
